

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第五章：シーケンスとコルーチン &mdash; SICP in Python Japanese Edition 2015.04.30 ドキュメント</title>
    
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2015.04.30',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="top" title="SICP in Python Japanese Edition 2015.04.30 ドキュメント" href="index.html" />
    <link rel="prev" title="第四章：分散・並行コンピューティング" href="4.communication.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="4.communication.html" title="第四章：分散・並行コンピューティング"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SICP in Python Japanese Edition 2015.04.30 ドキュメント</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>前のトピックへ</h4>
  <p class="topless"><a href="4.communication.html"
                        title="前の章へ">第四章：分散・並行コンピューティング</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/5.streams.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>第五章：シーケンスとコルーチン<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>5.1   Introduction</p>
<p>In this chapter, we continue our discussion of real-world applications by developing new tools to process sequential data. In Chapter 2, we introduced a sequence interface, implemented in Python by built-in data types such as tuple and list. Sequences supported two operations: querying their length and accessing an element by index. In Chapter 3, we developed a user-defined implementations of the sequence interface, the Rlist class for representing recursive lists. These sequence types proved effective for representing and accessing a wide variety of sequential datasets.</p>
<p>However, representing sequential data using the sequence abstraction has two important limitations. The first is that a sequence of length n typically takes up an amount of memory proportional to n. Therefore, the longer a sequence is, the more memory it takes to represent it.</p>
<p>The second limitation of sequences is that sequences can only represent datasets of known, finite length. Many sequential collections that we may want to represent do not have a well-defined length, and some are even infinite. Two mathematical examples of infinite sequences are the positive integers and the Fibonacci numbers. Sequential data sets of unbounded length also appear in other computational domains. For instance, the sequence of all Twitter posts grows longer with every second and therefore does not have a fixed length. Likewise, the sequence of telephone calls sent through a cell tower, the sequence of mouse movements made by a computer user, and the sequence of acceleration measurements from sensors on an aircraft all extend without bound as the world evolves.</p>
<p>In this chapter, we introduce new constructs for working with sequential data that are designed to accommodate collections of unknown or unbounded length, while using limited memory. We also discuss how these tools can be used with a programming construct called a coroutine to create efficient, modular data processing pipelines.
5.2   Implicit Sequences</p>
<p>The central observation that will lead us to efficient processing of sequential data is that a sequence can be represented using programming constructs without each element being stored explicitly in the memory of the computer. To put this idea into practice, we will construct objects that provides access to all of the elements of some sequential dataset that an application may desire, but without computing all of those elements in advance and storing them.</p>
<p>A simple example of this idea arises in the range sequence type introduced in Chapter 2. A range represents a consecutive, bounded sequence of integers. However, it is not the case that each element of that sequence is represented explicitly in memory. Instead, when an element is requested from a range, it is computed. Hence, we can represent very large ranges of integers without using large blocks of memory. Only the end points of the range are stored as part of the range object, and elements are computed on the fly.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">1000000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="mi">45006230</span><span class="p">]</span>
<span class="go">45016230</span>
</pre></div>
</div>
<p>In this example, not all 999,990,000 integers in this range are stored when the range instance is constructed. Instead, the range object adds the first element 10,000 to the index 45,006,230 to produce the element 45,016,230. Computing values on demand, rather than retrieving them from an existing representation, is an example of lazy computation. Computer science is a discipline that celebrates laziness as an important computational tool.</p>
<p>An iterator is an object that provides sequential access to an underlying sequential dataset. Iterators are built-in objects in many programming languages, including Python. The iterator abstraction has two components: a mechanism for retrieving the next element in some underlying series of elements and a mechanism for signaling that the end of the series has been reached and no further elements remain. In programming languages with built-in object systems, this abstraction typically corresponds to a particular interface that can be implemented by classes. The Python interface for iterators is described in the next section.</p>
<p>The usefulness of iterators is derived from the fact that the underlying series of data for an iterator may not be represented explicitly in memory. An iterator provides a mechanism for considering each of a series of values in turn, but all of those elements do not need to be stored simultaneously. Instead, when the next element is requested from an iterator, that element may be computed on demand instead of being retrieved from an existing memory source.</p>
<p>Ranges are able to compute the elements of a sequence lazily because the sequence represented is uniform, and any element is easy to compute from the starting and ending bounds of the range. Iterators allow for lazy generation of a much broader class of underlying sequential datasets, because they do not need to provide access to arbitrary elements of the underlying series. Instead, they must only compute the next element of the series, in order, each time another element is requested. While not as flexible as accessing arbitrary elements of a sequence (called random access), sequential access to sequential data series is often sufficient for data processing applications.
5.2.1   Python Iterators</p>
<p>The Python iterator interface includes two messages. The __next__ message queries the iterator for the next element of the underlying series that it represents. In response to invoking __next__ as a method, an iterator can perform arbitrary computation in order to either retrieve or compute the next element in an underlying series. Calls to __next__ make a mutating change to the iterator: they advance the position of the iterator. Hence, multiple calls to __next__ will return sequential elements of an underlying series. Python signals that the end of an underlying series has been reached by raising a StopIteration exception during a call to __next__.</p>
<p>The Letters class below iterates over an underlying series of letters from a to d. The member variable current stores the current letter in the series, and the __next__ method returns this letter and uses it to compute a new value for current.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Letters</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">        def __init__(self):</span>
<span class="go">            self.current = &#39;a&#39;</span>
<span class="go">        def __next__(self):</span>
<span class="go">            if self.current &gt; &#39;d&#39;:</span>
<span class="go">                raise StopIteration</span>
<span class="go">            result = self.current</span>
<span class="go">            self.current = chr(ord(result)+1)</span>
<span class="go">            return result</span>
<span class="go">        def __iter__(self):</span>
<span class="go">            return self</span>
</pre></div>
</div>
<p>The __iter__ message is the second required message of the Python iterator interface. It simply returns the iterator; it is useful for providing a common interface to iterators and sequences, as described in the next section.</p>
<p>Using this class, we can access letters in sequence.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span> <span class="o">=</span> <span class="n">Letters</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">&#39;d&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">12</span>, in <span class="n">next</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>A Letters instance can only be iterated through once. Once its __next__() method raises a StopIteration exception, it continues to do so from then on. There is no way to reset it; one must create a new instance.</p>
<p>Iterators also allow us to represent infinite series by implementing a __next__ method that never raises a StopIteration exception. For example, the Positives class below iterates over the infinite series of positive integers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Positives</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">        def __init__(self):</span>
<span class="go">            self.current = 0;</span>
<span class="go">        def __next__(self):</span>
<span class="go">            result = self.current</span>
<span class="go">            self.current += 1</span>
<span class="go">            return result</span>
<span class="go">        def __iter__(self):</span>
<span class="go">            return self</span>
</pre></div>
</div>
<p>5.2.2   For Statements</p>
<p>In Python, sequences can expose themselves to iteration by implementing the __iter__ message. If an object represents sequential data, it can serve as an iterable object in a for statement by returning an iterator object in response to the __iter__ message. This iterator is meant to have a __next__() method that returns each element of the sequence in turn, eventually raising a StopIteration exception when the end of the sequence is reached.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
<span class="go">        print(item)</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
</pre></div>
</div>
<p>In the above example, the counts list returns an iterator in response to a call to its __iter__() method. The for statement then calls that iterator&#8217;s __next__() method repeatedly, and assigns the returned value to item each time. This process continues until the iterator raises a StopIteration exception, at which point the for statement concludes.</p>
<p>With our knowledge of iterators, we can implement the evaluation rule of a for statement in terms of while, assignment, and try statements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="go">        while True:</span>
<span class="go">            item = i.__next__()</span>
<span class="go">            print(item)</span>
<span class="go">    except StopIteration:</span>
<span class="go">        pass</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Above, the iterator returned by invoking the __iter__ method of counts is bound to a name i so that it can be queried for each element in turn. The handling clause for the StopIteration exception does nothing, but handling the exception provides a control mechanism for exiting the while loop.
5.2.3   Generators and Yield Statements</p>
<p>The Letters and Positives objects above require us to introduce a new field self.current into our object to keep track of progress through the sequence. With simple sequences like those shown above, this can be done easily. With complex sequences, however, it can be quite difficult for the __next__() function to save its place in the calculation. Generators allow us to define more complicated iterations by leveraging the features of the Python interpreter.</p>
<p>A generator is an iterator returned by a special class of function called a generator function. Generator functions are distinguished from regular functions in that rather than containing return statements in their body, they use yield statement to return elements of a series.</p>
<p>Generators do not use attributes of an object to track their progress through a series. Instead, they control the execution of the generator function, which runs until the next yield statement is executed each time the generator&#8217;s __next__ method is invoked. The Letters iterator can be implemented much more compactly using a generator function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">letters_generator</span><span class="p">():</span>
<span class="go">        current = &#39;a&#39;</span>
<span class="go">        while current &lt;= &#39;d&#39;:</span>
<span class="go">            yield current</span>
<span class="go">            current = chr(ord(current)+1)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">letters_generator</span><span class="p">():</span>
<span class="go">        print(letter)</span>
<span class="go">a</span>
<span class="go">b</span>
<span class="go">c</span>
<span class="go">d</span>
</pre></div>
</div>
<p>Even though we never explicitly defined __iter__() or __next__() methods, Python understands that when we use the yield statement, we are defining a generator function. When called, a generator function doesn&#8217;t return a particular yielded value, but instead a generator (which is a type of iterator) that itself can return the yielded values. A generator object has __iter__ and __next__ methods, and each call to __next__ continues execution of the generator function from wherever it left off previously until another yield statement is executed.</p>
<p>The first time __next__ is called, the program executes statements from the body of the letters_generator function until it encounters the yield statement. Then, it pauses and returns the value of current. yield statements do not destroy the newly created environment, they preserve it for later. When __next__ is called again, execution resumes where it left off. The values of current and of any other bound names in the scope of letters_generator are preserved across subsequent calls to __next__.</p>
<p>We can walk through the generator by manually calling ____next__():</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span> <span class="o">=</span> <span class="n">letters_generator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">&lt;class &#39;generator&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">&#39;d&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>The generator does not start executing any of the body statements of its generator function until the first time __next__() is called.
5.2.4   Iterables</p>
<p>In Python, iterators only make a single pass over the elements of an underlying series. After that pass, the iterator will continue to raise a StopIteration exception when __next__() is called. Many applications require iteration over elements multiple times. For example, we have to iterate over a list many times in order to enumerate all pairs of elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">all_pairs</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="go">        for item1 in s:</span>
<span class="go">            for item2 in s:</span>
<span class="go">                yield (item1, item2)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">all_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="go">[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]</span>
</pre></div>
</div>
<p>Sequences are not themselves iterators, but instead iterable objects. The iterable interface in Python consists of a single message, __iter__, that returns an iterator. The built-in sequence types in Python return new instances of iterators when their __iter__ methods are invoked. If an iterable object returns a fresh instance of an iterator each time __iter__ is called, then it can be iterated over multiple times.</p>
<p>New iterable classes can be defined by implementing the iterable interface. For example, the iterable LetterIterable class below returns a new iterator over letters each time __iter__ is invoked.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">LetterIterable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">        def __iter__(self):</span>
<span class="go">            current = &#39;a&#39;</span>
<span class="go">            while current &lt;= &#39;d&#39;:</span>
<span class="go">                yield current</span>
<span class="go">                current = chr(ord(current)+1)</span>
</pre></div>
</div>
<p>The __iter__ method is a generator function; it returns a generator object that yields the letters &#8216;a&#8217; through &#8216;d&#8217;.</p>
<p>A Letters iterator object gets &#8220;used up&#8221; after a single iteration, whereas the LetterIterable object can be iterated over multiple times. As a result, a LetterIterable instance can serve as an argument to all_pairs.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span> <span class="o">=</span> <span class="n">LetterIterable</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">all_pairs</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">(&#39;a&#39;, &#39;a&#39;)</span>
</pre></div>
</div>
<p>5.2.5   Streams</p>
<p>Streams offer a final way to represent sequential data implicity. A stream is a lazily computed recursive list. Like the Rlist class from Chapter 3, a Stream instance responds to requests for its first element and the rest of the stream. Like an Rlist, the rest of a Stream is itself a Stream. Unlike an Rlist, the rest of a stream is only computed when it is looked up, rather than being stored in advance. That is, the rest of a stream is computed lazily.</p>
<p>To achieve this lazy evaluation, a stream stores a function that computes the rest of the stream. Whenever this function is called, its returned value is cached as part of the stream in an attribute called _rest, named with an underscore to indicate that it should not be accessed directly. The accessible attribute rest is a property method that returns the rest of the stream, computing it if necessary. With this design, a stream stores how to compute the rest of the stream, rather than always storing it explicitly.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Stream</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">        &quot;&quot;&quot;A lazily computed recursive list.&quot;&quot;&quot;</span>
<span class="go">        def __init__(self, first, compute_rest, empty=False):</span>
<span class="go">            self.first = first</span>
<span class="go">            self._compute_rest = compute_rest</span>
<span class="go">            self.empty = empty</span>
<span class="go">            self._rest = None</span>
<span class="go">            self._computed = False</span>
<span class="go">        @property</span>
<span class="go">        def rest(self):</span>
<span class="go">            &quot;&quot;&quot;Return the rest of the stream, computing it if necessary.&quot;&quot;&quot;</span>
<span class="go">            assert not self.empty, &#39;Empty streams have no rest.&#39;</span>
<span class="go">            if not self._computed:</span>
<span class="go">                self._rest = self._compute_rest()</span>
<span class="go">                self._computed = True</span>
<span class="go">            return self._rest</span>
<span class="go">        def __repr__(self):</span>
<span class="go">            if self.empty:</span>
<span class="go">                return &#39;&lt;empty stream&gt;&#39;</span>
<span class="go">            return &#39;Stream({0}, &lt;compute_rest&gt;)&#39;.format(repr(self.first))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Stream</span><span class="o">.</span><span class="n">empty</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>A recursive list is defined using a nested expression. For example, we can create an Rlist that represents the elements 1 then 5 as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Rlist</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Rlist</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">Rlist</span><span class="o">.</span><span class="n">empty</span><span class="p">))</span>
</pre></div>
</div>
<p>Likewise, we can create a Stream representing the same series. The Stream does not actually compute the second element 5 until the rest of the stream is requested.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">Stream</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">Stream</span><span class="o">.</span><span class="n">empty</span><span class="p">))</span>
</pre></div>
</div>
<p>Here, 1 is the first element of the stream, and the lambda expression that follows returns a function for computing the rest of the stream. The second element of the computed stream is a function that returns an empty stream.</p>
<p>Accessing the elements of recursive list r and stream s proceed similarly. However, while 5 is stored within r, it is computed on demand for s via addition the first time that it is requested.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">first</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">first</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">first</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">first</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">rest</span>
<span class="go">Rlist(5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">rest</span>
<span class="go">Stream(5, &lt;compute_rest&gt;)</span>
</pre></div>
</div>
<p>While the rest of r is a one-element recursive list, the rest of s includes a function to compute the rest; the fact that it will return the empty stream may not yet have been discovered.</p>
<p>When a Stream instance is constructed, the field self._computed is False, signifying that the _rest of the Stream has not yet been computed. When the rest attribute is requested via a dot expression, the rest method is invoked, which triggers computation with self._rest = self.compute_rest. Because of the caching mechanism within a Stream, the compute_rest function is only ever called once.</p>
<p>The essential properties of a compute_rest function are that it takes no arguments, and it returns a Stream.</p>
<p>Lazy evaluation gives us the ability to represent infinite sequential datasets using streams. For example, we can represent increasing integers, starting at any first value.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_integer_stream</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="go">      def compute_rest():</span>
<span class="go">        return make_integer_stream(first+1)</span>
<span class="go">      return Stream(first, compute_rest)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ints</span> <span class="o">=</span> <span class="n">make_integer_stream</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ints</span>
<span class="go">Stream(1, &lt;compute_rest&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ints</span><span class="o">.</span><span class="n">first</span>
<span class="go">1</span>
</pre></div>
</div>
<p>When make_integer_stream is called for the first time, it returns a stream whose first is the first integer in the sequence (1 by default). However, make_integer_stream is actually recursive because this stream&#8217;s compute_rest calls make_integer_stream again, with an incremented argument. This makes make_integer_stream recursive, but also lazy.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ints</span><span class="o">.</span><span class="n">first</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ints</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">first</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ints</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">rest</span>
<span class="go">Stream(3, &lt;compute_rest&gt;)</span>
</pre></div>
</div>
<p>Recursive calls are only made to make_integer_stream whenever the rest of an integer stream is requested.</p>
<p>The same higher-order functions that manipulate sequences &#8211; map and filter &#8211; also apply to streams, although their implementations must change to apply their argument functions lazily. The function map_stream maps a function over a stream, which produces a new stream. The locally defined compute_rest function ensures that the function will be mapped onto the rest of the stream whenever the rest is computed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">map_stream</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="go">        if s.empty:</span>
<span class="go">            return s</span>
<span class="go">        def compute_rest():</span>
<span class="go">            return map_stream(fn, s.rest)</span>
<span class="go">        return Stream(fn(s.first), compute_rest)</span>
</pre></div>
</div>
<p>A stream can be filtered by defining a compute_rest function that applies the filter function to the rest of the stream. If the filter function rejects the first element of the stream, the rest is computed immediately. Because filter_stream is recursive, the rest may be computed multiple times until a valid first element is found.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">filter_stream</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="go">        if s.empty:</span>
<span class="go">            return s</span>
<span class="go">        def compute_rest():</span>
<span class="go">            return filter_stream(fn, s.rest)</span>
<span class="go">        if fn(s.first):</span>
<span class="go">            return Stream(s.first, compute_rest)</span>
<span class="go">        return compute_rest()</span>
</pre></div>
</div>
<p>The map_stream and filter_stream functions exhibit a common pattern in stream processing: a locally defined compute_rest function recursively applies a processing function to the rest of the stream whenever the rest is computed.</p>
<p>To inspect the contents of a stream, we can truncate it to finite length and convert it to a Python list.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">truncate_stream</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="go">        if s.empty or k == 0:</span>
<span class="go">            return Stream.empty</span>
<span class="go">        def compute_rest():</span>
<span class="go">            return truncate_stream(s.rest, k-1)</span>
<span class="go">        return Stream(s.first, compute_rest)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">stream_to_list</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="go">        r = []</span>
<span class="go">        while not s.empty:</span>
<span class="go">            r.append(s.first)</span>
<span class="go">            s = s.rest</span>
<span class="go">        return r</span>
</pre></div>
</div>
<p>These convenience functions allow us to verify our map_stream implementation with a simple example that squares the integers from 3 to 7.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">make_integer_stream</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">Stream(3, &lt;compute_rest&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">map_stream</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">Stream(9, &lt;compute_rest&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stream_to_list</span><span class="p">(</span><span class="n">truncate_stream</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">[9, 16, 25, 36, 49]</span>
</pre></div>
</div>
<p>We can use our filter_stream function to define a stream of prime numbers using the sieve of Eratosthenes, which filters a stream of integers to remove all numbers that are multiples of its first element. By successively filtering with each prime, all composite numbers are removed from the stream.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">primes</span><span class="p">(</span><span class="n">pos_stream</span><span class="p">):</span>
<span class="go">        def not_divible(x):</span>
<span class="go">            return x % pos_stream.first != 0</span>
<span class="go">        def compute_rest():</span>
<span class="go">            return primes(filter_stream(not_divible, pos_stream.rest))</span>
<span class="go">        return Stream(pos_stream.first, compute_rest)</span>
</pre></div>
</div>
<p>By truncating the primes stream, we can enumerate any prefix of the prime numbers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">primes</span><span class="p">(</span><span class="n">make_integer_stream</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stream_to_list</span><span class="p">(</span><span class="n">truncate_stream</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="go">[2, 3, 5, 7, 11, 13, 17]</span>
</pre></div>
</div>
<p>Streams contrast with iterators in that they can be passed to pure functions multiple times and yield the same result each time. The primes stream is not &#8220;used up&#8221; by converting it to a list. That is, the first element of p1 is still 2 after converting the prefix of the stream to a list.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">first</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Just as recursive lists provide a simple implementation of the sequence abstraction, streams provide a simple, functional, recursive data structure that implements lazy evaluation through the use of higher-order functions.
5.3   Coroutines</p>
<p>Much of this text has focused on techniques for decomposing complex programs into small, modular components. When the logic for a function with complex behavior is divided into several self-contained steps that are themselves functions, these functions are called helper functions or subroutines. Subroutines are called by a main function that is responsible for coordinating the use of several subroutines.
img/subroutine.png</p>
<p>In this section, we introduce a different way of decomposing complex computations using coroutines, an approach that is particularly applicable to the task of processing sequential data. Like a subroutine, a coroutine computes a single step of a complex computation. However, when using coroutines, there is no main function to coordinate results. Instead coroutines themselves link together to form a pipeline. There may be a coroutine for consuming the incoming data and sending it to other coroutines. There may be coroutines that each do simple processing steps on data sent to them, and there may finally be another coroutine that outputs a final result.
img/coroutine.png</p>
<p>The difference between coroutines and subroutines is conceptual: subroutines slot into an overarching function to which they are subordinate, whereas coroutines are all colleagues, they cooperate to form a pipeline without any supervising function responsible for calling them in a particular order.</p>
<p>In this section, we will learn how Python supports building coroutines with the yield and send() statements. Then, we will look at different roles that coroutines can play in a pipeline, and how coroutines can support multitasking.
5.3.1   Python Coroutines</p>
<p>In the previous section, we introduced generator functions, which use yield to return values. Python generator functions can also consume values using a (yield) statement. In addition two new methods on generator objects, send() and close(), create a framework for objects that consume and produce values. Generator functions that define these objects are coroutines.</p>
<p>Coroutines consume values using a (yield) statement as follows:</p>
<p>value = (yield)</p>
<p>With this syntax, execution pauses at this statement until the object&#8217;s send method is invoked with an argument:</p>
<p>coroutine.send(data)</p>
<p>Then, execution resumes, with value being assigned to the value of data. To signal the end of a computation, we shut down a coroutine using the close() method. This raises a GeneratorExit exception inside the coroutine, which we can catch with a try/except clause.</p>
<p>The example below illustrates these concepts. It is a coroutine that prints strings that match a provided pattern.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
<span class="go">        print(&#39;Looking for &#39; + pattern)</span>
<span class="go">        try:</span>
<span class="go">            while True:</span>
<span class="go">                s = (yield)</span>
<span class="go">                if pattern in s:</span>
<span class="go">                    print(s)</span>
<span class="go">        except GeneratorExit:</span>
<span class="go">            print(&quot;=== Done ===&quot;)</span>
</pre></div>
</div>
<p>We initialize it with a pattern, and call __next__() to start execution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="s">&quot;Jabberwock&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">Looking for Jabberwock</span>
</pre></div>
</div>
<p>The call to __next__() causes the body of the function to be executed, so the line &#8220;Looking for jabberwock&#8221; gets printed out. Execution continues until the statement line = (yield) is encountered. Then, execution pauses, and waits for a value to be sent to m. We can send values to it using send.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;the Jabberwock with eyes of flame&quot;</span><span class="p">)</span>
<span class="go">the Jabberwock with eyes of flame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;came whiffling through the tulgey wood&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;and burbled as it came&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">=== Done ===</span>
</pre></div>
</div>
<p>When we call m.send with a value, evaluation resumes inside the coroutine m at the statement line = (yield), where the sent value is assigned to the variable line. Evaluation continues inside m, printing out the line if it matches, going through the loop until it encounters line = (yield) again. Then, evaluation pauses inside m and resumes where m.send was called.</p>
<p>We can chain functions that send() and functions that yield together achieve complex behaviors. For example, the function below splits a string named text into words and sends each word to another coroutine.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">next_coroutine</span><span class="p">):</span>
<span class="go">        for line in text.split():</span>
<span class="go">            next_coroutine.send(line)</span>
<span class="go">        next_coroutine.close()</span>
</pre></div>
</div>
<p>Each word is sent to the coroutine bound to next_coroutine, causing next_coroutine to start executing, and this function to pause and wait. It waits until next_coroutine pauses, at which point the function resumes by sending the next word or completing.</p>
<p>If we chain this function together with match defined above, we can create a program that prints out only the words that match a particular word.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s">&#39;Commending spending is offending to people pending lending!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matcher</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="s">&#39;ending&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matcher</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">Looking for ending</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">read</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">matcher</span><span class="p">)</span>
<span class="go">Commending</span>
<span class="go">spending</span>
<span class="go">offending</span>
<span class="go">pending</span>
<span class="go">lending!</span>
<span class="go">=== Done ===</span>
</pre></div>
</div>
<p>The read function sends each word to the coroutine matcher, which prints out any input that matches its pattern. Within the matcher coroutine, the line s = (yield) waits for each sent word, and it transfers control back to read when it is reached.
img/read-match-coroutine.png
5.3.2   Produce, Filter, and Consume</p>
<p>Coroutines can have different roles depending on how they use yield and send():
img/produce-filter-consume.png</p>
<blockquote>
<div>A Producer creates items in a series and uses send(), but not (yield)
A Filter uses (yield) to consume items and send() to send result to a next step.
A Consumer uses (yield) to consume items, but does not send.</div></blockquote>
<p>The function read above is an example of a producer. It does not use (yield), but uses send to produce data items. The function match is an example of a consumer. It does not send anything, but consumes data with (yield).We can break up match into a filter and a consumer. The filter would be a coroutine that only sends on strings that match its pattern.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_filter</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">next_coroutine</span><span class="p">):</span>
<span class="go">        print(&#39;Looking for &#39; + pattern)</span>
<span class="go">        try:</span>
<span class="go">            while True:</span>
<span class="go">                s = (yield)</span>
<span class="go">                if pattern in s:</span>
<span class="go">                    next_coroutine.send(s)</span>
<span class="go">        except GeneratorExit:</span>
<span class="go">            next_coroutine.close()</span>
</pre></div>
</div>
<p>And the consumer would be a function that printed out lines sent to it.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_consumer</span><span class="p">():</span>
<span class="go">        print(&#39;Preparing to print&#39;)</span>
<span class="go">        try:</span>
<span class="go">            while True:</span>
<span class="go">                line = (yield)</span>
<span class="go">                print(line)</span>
<span class="go">        except GeneratorExit:</span>
<span class="go">            print(&quot;=== Done ===&quot;)</span>
</pre></div>
</div>
<p>When a filter or consumer is constructed, its __next__ method must be invoked to start its execution.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">printer</span> <span class="o">=</span> <span class="n">print_consumer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printer</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">Preparing to print</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matcher</span> <span class="o">=</span> <span class="n">match_filter</span><span class="p">(</span><span class="s">&#39;pend&#39;</span><span class="p">,</span> <span class="n">printer</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matcher</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">Looking for pend</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">read</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">matcher</span><span class="p">)</span>
<span class="go">spending</span>
<span class="go">pending</span>
<span class="go">=== Done ===</span>
</pre></div>
</div>
<p>Even though the name filter implies removing items, filters can transform items as well. The function below is an example of a filter that transforms items. It consumes strings and sends along a dictionary of the number of times different letters occur in the string.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count_letters</span><span class="p">(</span><span class="n">next_coroutine</span><span class="p">):</span>
<span class="go">        try:</span>
<span class="go">            while True:</span>
<span class="go">                s = (yield)</span>
<span class="go">                counts = {letter:s.count(letter) for letter in set(s)}</span>
<span class="go">                next_coroutine.send(counts)</span>
<span class="go">        except GeneratorExit as e:</span>
<span class="go">            next_coroutine.close()</span>
</pre></div>
</div>
<p>We can use it to count the most frequently-used letters in text using a consumer that adds up dictionaries and finds the most frequent key.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_dictionaries</span><span class="p">():</span>
<span class="go">        total = {}</span>
<span class="go">        try:</span>
<span class="go">            while True:</span>
<span class="go">                counts = (yield)</span>
<span class="go">                for letter, count in counts.items():</span>
<span class="go">                    total[letter] = count + total.get(letter, 0)</span>
<span class="go">        except GeneratorExit:</span>
<span class="go">            max_letter = max(total.items(), key=lambda t: t[1])[0]</span>
<span class="go">            print(&quot;Most frequent letter: &quot; + max_letter)</span>
</pre></div>
</div>
<p>To run this pipeline on a file, we must first read the lines of a file one-by-one. Then, we send the results through count_letters and finally to sum_dictionaries. We can re-use the read coroutine to read the lines of a file.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sum_dictionaries</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">count_letters</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">read</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">Most frequent letter: n</span>
</pre></div>
</div>
<p>5.3.3   Multitasking</p>
<p>A producer or filter does not have to be restricted to just one next step. It can have multiple coroutines downstream of it, and send() data to all of them. For example, here is a version of read that sends the words in a string to multiple next steps.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">read_to_many</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">coroutines</span><span class="p">):</span>
<span class="go">        for word in text.split():</span>
<span class="go">            for coroutine in coroutines:</span>
<span class="go">                coroutine.send(word)</span>
<span class="go">        for coroutine in coroutines:</span>
<span class="go">            coroutine.close()</span>
</pre></div>
</div>
<p>We can use it to examine the same text for multiple words:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="s">&quot;mend&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">Looking for mend</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="s">&quot;pe&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="go">Looking for pe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">read_to_many</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">])</span>
<span class="go">Commending</span>
<span class="go">spending</span>
<span class="go">people</span>
<span class="go">pending</span>
<span class="go">=== Done ===</span>
<span class="go">=== Done ===</span>
</pre></div>
</div>
<p>First, read_to_many calls send(word) on m. The coroutine, which is waiting at text = (yield) runs through its loop, prints out a match if found, and resumes waiting for the next send. Execution then returns to read_to_many, which proceeds to send the same line to p. Thus, the words of text are printed in order.</p>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="4.communication.html" title="第四章：分散・並行コンピューティング"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SICP in Python Japanese Edition 2015.04.30 ドキュメント</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Paul Hilfinger.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1 で生成しました。
    </div>
  </body>
</html>